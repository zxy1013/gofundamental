Object Relational Mapping：对象关系映射，把面向对象的概念和数据库中表的概念对应起来。具体来说，定义一个对象，对应着一张表。这个对象的实例，就对应着表中的一条记录。屏蔽了sql具体语法。

![image-20200917213143434](https://gitee.com/moxi159753/LearningNotes/raw/master/Golang/Gin%E6%A1%86%E6%9E%B6/3_GORM%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/images/image-20200917213143434.png)

执行sql，要求程序开发者熟悉sql语句，结构体和 SQL数据库存在映射，这个时候就有了ORM语句。表中的列映射为结构体中的字段。

![image-20200917213229165](https://gitee.com/moxi159753/LearningNotes/raw/master/Golang/Gin%E6%A1%86%E6%9E%B6/3_GORM%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/images/image-20200917213229165.png)

一句话说：就是将数据库中的表数据 和 结构体进行对应的关系

![image-20200917213306696](https://gitee.com/moxi159753/LearningNotes/raw/master/Golang/Gin%E6%A1%86%E6%9E%B6/3_GORM%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/images/image-20200917213306696.png)

**ORM的优缺点**

**优点：**提高开发效率 屏蔽sql细节 屏蔽不同数据库之间的差异

**缺点:**   牺牲执行性能【中间多了一个环节】牺牲灵活性 弱化SQL能力 太多依赖orm会导致sql理解不够

sql为主，orm为辅。orm是为了增加代码的可维护性和开发效率。

**gorm介绍**

[中文官方网站](https://gorm.io/zh_CN/)内含十分齐全的中文文档

gorm是一个使用Go语言编写的ORM框架。它文档齐全，对开发者友好，支持主流数据库。

**安装** 常用gorm

```
go mod init 27orm
```

**GORM基本示例**

**注意:**

1. 本文以MySQL数据库为例，讲解GORM各项功能的主要使用方法。
2. 往下阅读本文前，你需要有一个能够成功连接上的MySQL数据库实例。

**创建数据库**

在使用GORM前手动创建数据库`db1`：

```
CREATE DATABASE fwbzs;
```

##### **GORM操作MySQL**

使用GORM连接上面的`fwbzs`进行创建、查询、更新、删除操作。

```go
package main

import (
	"fmt"
	"gorm.io/driver/mysql"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"
	"log"
	"os"
	"time"
)

// UserInfo 用户信息 ---> 对应数据表
type UserInfo struct {
	gorm.Model // 加上内置的结构体
	Name string
	Gender string
	Hobby string
}

func main() {
	dsn := "root:zxy19981013@(127.0.0.1:3306)/fwbzs?charset=utf8mb4&parseTime=True&loc=Local"

	// 设置全局的logger 会在我们执行每个sql语句的时候打印sql
	newLogger := logger.New(
		log.New(os.Stdout,"\r\n",log.LstdFlags), // io.write
		logger.Config{
			SlowThreshold: time.Second, // 慢sql阈值
			LogLevel: logger.Info, // sql 输出 level
			Colorful: true, // 使用彩色打印
		})

	// 打开数据库
	db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{
		Logger: newLogger,
	})
	if err!= nil{
		panic(err)
	}

	// 定义一个表结构 自动迁移 将结构体和数据表同步 自动创建user_infos表
	db.AutoMigrate(&UserInfo{}) // 此处有sql语句 CREATE TABLE `user_infos` (`id` bigint unsigned AUTO_INCREMENT,`created_at` datetime(3) NULL,`updated_at` datetime(3) NULL,`deleted_at` datetime(3) NULL,`name` longtext,`gender` longtext,`hobby` longtext,PRIMARY KEY (`id`),INDEX idx_user_infos_deleted_at (`deleted_at`))

	// 创建数据行
	u1 := UserInfo{Name: "ff", Gender: "男", Hobby: "篮球"}
	u2 := UserInfo{Name:"zz", Gender: "女", Hobby: "足球"}
	// 创建记录
	db.Create(&u1) // INSERT INTO `user_infos` (`created_at`,`updated_at`,`deleted_at`,`name`,`gender`,`hobby`) VALUES ('2022-02-16 20:47:21.91','2022-02-16 20:47:21.91',NULL,'ff','男','篮球')
	db.Create(&u2)

	// 查询表第一条数据
	var u = new(UserInfo)
	db.First(u) // SELECT * FROM `user_infos` WHERE `user_infos`.`deleted_at` IS NULL ORDER BY `user_infos`.`id` LIMIT 1
	fmt.Printf("u:%#v\n", u)
	// 查询符合条件的数据
	var uu UserInfo
	db.Find(&uu, "hobby=?", "足球") // SELECT * FROM `user_infos` WHERE hobby='足球' AND `user_infos`.`deleted_at` IS NULL
	fmt.Printf("%#v\n", uu)

	// 更新 Update可以更新零字段
	db.Model(&uu).Update("hobby", "双色球") // UPDATE `user_infos` SET `hobby`='双色球',`updated_at`='2022-02-16 20:47:21.94' WHERE `id` = 2 AND `user_infos`.`deleted_at` IS NULL
	db.Model(&uu).Updates(UserInfo{Name: "aa",Gender: "中",Hobby: ""}) // Updates仅更新非零字段 Hobby: ""不更新
	// UPDATE `user_infos` SET `updated_at`='2022-02-16 20:53:39.563',`name`='aa',`gender`='中' WHERE `id` = 2 AND `user_infos`.`deleted_at` IS NULL
	// 使用 struct 更新时，只会更新非零值字段，若想更新所有字段，请使用map[string]interface{} 或sql的NullString
	s := map[string]interface{}{"Name": "aa1","Gender": "中1","Hobby": ""}
	db.Model(&uu).Updates(s)
	// UPDATE `user_infos` SET `gender`='中1',`hobby`='',`name`='aa1',`updated_at`='2022-02-16 21:01:59.876' WHERE `id` = 2 AND `user_infos`.`deleted_at` IS NULL

	// 删除 逻辑删除
	db.Delete(&u) // UPDATE `user_infos` SET `deleted_at`='2022-02-16 20:47:22.155' WHERE `user_infos`.`id` = 1 AND `user_infos`.`id` = 1 AND `user_infos`.`deleted_at` IS NULL
}
```

**GORM Model定义**

在使用ORM工具时，通常我们需要在代码中定义模型（Models）与数据库中的数据表进行映射，在GORM中模型（Models）通常是正常定义的结构体、基本的go类型或它们的指针。 同时也支持`sql.Scanner`及`driver.Valuer`接口（interfaces）。

**gorm.Model**

为了方便模型定义，GORM内置了一个`gorm.Model`结构体。`gorm.Model`是一个包含了`ID`, `CreatedAt`, `UpdatedAt`, `DeletedAt`四个字段的Golang结构体。

```go
// gorm.Model 定义
type Model struct {
  ID        uint `gorm:"primary_key"`
  CreatedAt time.Time
  UpdatedAt time.Time
  DeletedAt *time.Time
}
```

可以将它嵌入到自己的模型中：

```go
// 将 `ID`, `CreatedAt`, `UpdatedAt`, `DeletedAt`字段注入到`User`模型中
type User struct {
  gorm.Model
  Name string
}
```

当然也可以完全自己定义模型：

```go
// 不使用gorm.Model，自行定义模型
type User struct {
  ID   int
  Name string
}
```

**模型定义示例**

```go
// 定义模型
type User struct {
	gorm.Model // 结构体嵌套 内嵌gorm.Model
	Name         string
	Age          sql.NullInt64 // 零值类型
	Birthday     *time.Time
	Email        string  `gorm:"type:varchar(100);unique_index"` // 唯一索引
	Role         string  `gorm:"size:255"` // 设置字段大小为255
	MemberNumber *string `gorm:"unique;not null"` // 设置会员号（member number）唯一并且不为空
	Num          int     `gorm:"AUTO_INCREMENT"` // 设置 num 为自增类型
	Address      string  `gorm:"index:addr"` // 给address字段创建名为addr的索引
	IgnoreMe     int     `gorm:"-"` // 忽略本字段
}
```

**结构体标记（tags）**

使用结构体声明模型时，标记（tags）是可选项。gorm支持以下标记:

**支持的结构体标记（Struct tags）**

| 结构体标记（Tag） | 描述                                                     |
| ----------------- | -------------------------------------------------------- |
| Column            | 指定列名                                                 |
| Type              | 指定列数据类型                                           |
| Size              | 指定列大小, 默认值255                                    |
| PRIMARY_KEY       | 将列指定为主键                                           |
| UNIQUE            | 将列指定为唯一                                           |
| DEFAULT           | 指定列默认值                                             |
| PRECISION         | 指定列精度                                               |
| NOT NULL          | 将列指定为非 NULL                                        |
| AUTO_INCREMENT    | 指定列是否为自增类型                                     |
| INDEX             | 创建具有或不带名称的索引, 如果多个索引同名则创建复合索引 |
| UNIQUE_INDEX      | 和 `INDEX` 类似，只不过创建的是唯一索引                  |
| EMBEDDED          | 将结构设置为嵌入                                         |
| EMBEDDED_PREFIX   | 设置嵌入结构的前缀                                       |
| -                 | 忽略此字段                                               |

**关联相关标记（tags）**

| 结构体标记（Tag）                | 描述                               |
| -------------------------------- | ---------------------------------- |
| MANY2MANY                        | 指定连接表                         |
| FOREIGNKEY                       | 设置外键                           |
| ASSOCIATION_FOREIGNKEY           | 设置关联外键                       |
| POLYMORPHIC                      | 指定多态类型                       |
| POLYMORPHIC_VALUE                | 指定多态值                         |
| JOINTABLE_FOREIGNKEY             | 指定连接表的外键                   |
| ASSOCIATION_JOINTABLE_FOREIGNKEY | 指定连接表的关联外键               |
| SAVE_ASSOCIATIONS                | 是否自动完成 save 的相关操作       |
| ASSOCIATION_AUTOUPDATE           | 是否自动完成 update 的相关操作     |
| ASSOCIATION_AUTOCREATE           | 是否自动完成 create 的相关操作     |
| ASSOCIATION_SAVE_REFERENCE       | 是否自动完成引用的 save 的相关操作 |
| PRELOAD                          | 是否自动完成预加载的相关操作       |

**主键、表名、列名的约定**

**主键（Primary Key）**

GORM 默认会使用名为ID的字段作为表的主键。

```go
type User struct {
  ID   string // 名为`ID`的字段会默认作为表的主键
  Name string
}

// 使用`AnimalID`作为主键
type Animal struct {
  AnimalID int64 `gorm:"primary_key"`
  Name     string
  Age      int64
}
```

**表名（Table Name）**

表名默认就是结构体名称的复数，例如：

```go
type User struct {} // 默认表名是 `users`

// 将 User 的表名设置为 `profiles`
func (User) TableName() string {
  return "profiles"
}

func (u User) TableName() string {
  if u.Role == "admin" {
    return "admin_users"
  } else {
    return "users"
  }
}
```

也可以通过`Table()`指定表名：

```go
    // 使用User结构体创建名为`deleted_users`的表
    db.Table("deleted_users").CreateTable(&User{})

    var deleted_users []User
    db.Table("deleted_users").Find(&deleted_users)
    // SELECT * FROM deleted_users;

    db.Table("deleted_users").Where("name = ?", "jinzhu").Delete()
    // DELETE FROM deleted_users WHERE name = 'jinzhu';
```

```go
    // 打开数据库
	db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{
		NamingStrategy: schema.NamingStrategy{
			TablePrefix: "zzz_",
		},
		Logger: newLogger,
	})
```



**列名（Column Name）**

列名由字段名称进行下划线分割来生成

```go
type User struct {
  ID        uint      // column name is `id`
  Name      string    // column name is `name`
  Birthday  time.Time // column name is `birthday`
  CreatedAt time.Time // column name is `created_at`
}
```

可以使用结构体tag指定列名：

```go
type Animal struct {
  AnimalId    int64     `gorm:"column:beast_id"`         // set column name to `beast_id`
  Birthday    time.Time `gorm:"column:day_of_the_beast"` // set column name to `day_of_the_beast`
  Age         int64     `gorm:"column:age_of_the_beast"` // set column name to `age_of_the_beast`
}
```

**时间戳跟踪**

**CreatedAt**

如果模型有 `CreatedAt`字段，该字段的值将会是初次创建记录的时间。

```go
db.Create(&user) // `CreatedAt`将会是当前时间

// 可以使用`Update`方法来改变`CreateAt`的值
db.Model(&user).Update("CreatedAt", time.Now())
```

**UpdatedAt**

如果模型有`UpdatedAt`字段，该字段的值将会是每次更新记录的时间。

```go
db.Save(&user) // `UpdatedAt`将会是当前时间

db.Model(&user).Update("name", "jinzhu") // `UpdatedAt`将会是当前时间
```

**DeletedAt**

如果模型有`DeletedAt`字段，调用`Delete`删除该记录时，将会设置`DeletedAt`字段为当前时间，而不是直接将记录从数据库中删除。逻辑删除

##### **创建**

使用使用`NewRecord()`查询主键是否存在，主键为空使用`Create()`创建记录：

```go
package main

import (
	"fmt"
	"gorm.io/driver/mysql"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"
	"log"
	"os"
	"time"
)

// 定义模型
type User struct {
	ID int64
	Name string
	Age int64
}


func main() {
	dsn := "root:zxy19981013@(127.0.0.1:3306)/fwbzs?charset=utf8mb4&parseTime=True&loc=Local"

	// 设置全局的logger 会在我们执行每个sql语句的时候打印sql
	newLogger := logger.New(
		log.New(os.Stdout,"\r\n",log.LstdFlags), // io.write
		logger.Config{
			SlowThreshold: time.Second, // 慢sql阈值
			LogLevel: logger.Info, // sql 输出 level
			Colorful: true, // 使用彩色打印
		})

	// 打开数据库
	db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{
		Logger: newLogger,
	})
	if err!= nil{
		panic(err)
	}

	// 自动迁移 将结构体和数据表同步 自动创建users表
	db.AutoMigrate(&User{})

	user := User{Name: "zzz", Age: 18} // 代码层创建user对象

	result := db.Create(&user)
	fmt.Println(user.ID,result.Error,result.RowsAffected) // 1 <nil> 1

	// 批量插入 将slice传递给create方法，GORM将生成一个单一的SQL语句来插入所有数据
	var users = []User{{Name: "z", Age: 19},{Name: "z1", Age: 17},{Name: "z2", Age: 16}}
	// db.Create(&users) // INSERT INTO `users` (`name`,`age`) VALUES ('z',19),('z1',17),('z2',16)
	db.CreateInBatches(users,2) // 一次提交给mysql两条  分两次提交 因为sql语句有限制
	// INSERT INTO `users` (`name`,`age`) VALUES ('z',19),('z1',17)
	// INSERT INTO `users` (`name`,`age`) VALUES ('z2',16)

	for _,us := range users{
		fmt.Println(us.ID)
	}

	// map创建 INSERT INTO `users` (`age`,`name`) VALUES (11,'xx')
	s := map[string]interface{}{"Name": "xx","Age": 11}
	db.Model(&User{}).Create(s)
}
```

**默认值**

可以通过 tag 定义字段的默认值，比如： 重新删除表后运行

```go
type User struct {
  ID   int64
  Name string `gorm:"default:'xss'"`
  Age  int64
}

	user := User{Age: 18} // 代码层创建user对象
```

**注意：**通过tag定义字段的默认值，在创建记录时候生成的 SQL 语句会排除没有值或值为零的字段。 在将记录插入到数据库后，Gorm会从数据库加载那些字段的默认值。

```go
	var user = User{Name: "", Age: 99}
	db.Debug().Create(&user) // 存入的是 99 数据库默认补xss INSERT INTO `users` (`age`) VALUES (99)  
```

上面代码实际执行的SQL语句是`INSERT INTO users("age") values('99');`，排除了零值字段`Name`，而在数据库中这一条数据会使用设置的默认值`xss`作为Name字段的值。

**注意：**所有字段的零值, 比如`0`, `""`,`false`或者其零值，都不会保存到数据库内，但会使用他们的默认值。 如果想避免这种情况，可以考虑使用指针或实现 `Scanner/Valuer`接口，比如：

**使用指针方式实现零值存入数据库**

```go
// 定义模型
type User struct {
	ID   int64
	Name *string `gorm:"default:'zss'"` // 使用指针
	Age  int64
}

	var user = User{Name: new(string), Age: 18}
	db.Debug().Create(&user) // INSERT INTO `users` (`name`,`age`) VALUES ('',18)
```

**使用Scanner/Valuer接口方式实现零值存入数据库**

```go
// 定义模型
// 使用 Scanner/Valuer
type User struct {
	ID int64
	Name sql.NullString `gorm:"default:'zsss'"` // sql.NullString 实现了Scanner/Valuer接口
	Age  int64
}


	var user = User{Name: sql.NullString{"", true}, Age:18} // 指定标识符为true
	// db.Create(&user)   // 创建user到数据库中
	db.Debug().Create(&user) // INSERT INTO `users` (`name`,`age`) VALUES ('',18)
```

##### **查询**

**一般查询**

```go
package main

import (
	"fmt"
	"gorm.io/driver/mysql"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"
	"log"
	"os"
	"time"
)

// 定义模型
type User struct {
	ID int64
	Name string
	Age int64
}


func main() {
	dsn := "root:zxy19981013@(127.0.0.1:3306)/fwbzs?charset=utf8mb4&parseTime=True&loc=Local"

	// 设置全局的logger 会在我们执行每个sql语句的时候打印sql
	newLogger := logger.New(
		log.New(os.Stdout,"\r\n",log.LstdFlags), // io.write
		logger.Config{
			SlowThreshold: time.Second, // 慢sql阈值
			LogLevel: logger.Info, // sql 输出 level
			Colorful: true, // 使用彩色打印
		})

	// 打开数据库
	db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{
		Logger: newLogger,
	})
	if err!= nil{
		panic(err)
	}

	// 查询
	// 根据主键查询第一条记录 主键必须为id
	var user User // 声明结构体类型变量
	// db.First(&user) // SELECT * FROM `users`   ORDER BY `users`.`id` ASC LIMIT 1

	// 未指定排序获取一条记录
	// db.Take(&user) // SELECT * FROM `users`   LIMIT 1

	// 根据主键查询最后一条记录
	// db.Last(&user) // SELECT * FROM `users`   ORDER BY `users`.`id` DESC LIMIT 1

	// 查询所有的记录
	var users []User
	re := db.Find(&users) // SELECT * FROM `users`
	fmt.Println("总共记录",re.RowsAffected)


	// 查询指定的某条记录(仅当主键为整型时可用) 之前不能赋值
	// re := db.First(&user, 10) // SELECT * FROM `users`  WHERE (`users`.`id` = 10) ORDER BY `users`.`id` ASC LIMIT 1
	// fmt.Println(errors.Is(re.Error,gorm.ErrRecordNotFound)) // 判断是否未找到数据

	db.First(&user, []int{1,2,3}) // SELECT * FROM `users` WHERE `users`.`id` IN (1,2,3) ORDER BY `users`.`id` LIMIT 1
}
```

**Where 条件**

**普通SQL查询**

```go
	// where
	// Get first matched record  大小写不敏感
	db.Where(&User{Name:"zzz"}).First(&user)
	// SELECT * FROM `users` WHERE `users`.`name` = 'zzz' ORDER BY `users`.`id` LIMIT 1

	// Get all matched records
	//db.Where("name = ?", "zzz").Find(&users)
	// SELECT * FROM users WHERE name = 'zzz';

	// <> 不等于
	//db.Where("name <> ?", "zzz").Find(&users)
	// SELECT * FROM users WHERE name <> 'zzz';

	// IN
	//db.Where("name IN (?)", []string{"zzz", "z1 "}).Find(&users)
	// SELECT * FROM users WHERE name in ('zzz','z1');

	// LIKE
	//db.Where("name LIKE ?", "%x%").Find(&users)
	// SELECT * FROM users WHERE name LIKE '%x%';

	// AND
	// db.Where("name = ? AND age >= ?", "zzz", "22").Find(&users)
	// SELECT * FROM users WHERE name = 'zzz' AND age >= 22;

	// SELECT * FROM `users` WHERE `age` = 20 AND `name` = 'zzz'
	// db.Where(map[string]interface{}{"name": "zzz", "age": 20}).Find(&users)

	// SELECT * FROM `users` WHERE `users`.`id` IN (20,21,22)
	db.Where([]int64{20, 21, 22}).Find(&users)
```

**Struct & Map查询**

```go
    // Struct
    db.Where(&User{Name: "zzz", Age: 20}).First(&user)
    // SELECT * FROM users WHERE name = "zzz" AND age = 20 LIMIT 1;

    // Map
    db.Where(map[string]interface{}{"name": "zzz", "age": 20}).Find(&users)
    // SELECT * FROM users WHERE name = "zzz" AND age = 20;

    // 主键的切片
    db.Where([]int64{20, 21, 22}).Find(&users)
    // SELECT * FROM `users` WHERE `users`.`id` IN (20,21,22)
```

**提示：**当通过结构体进行查询时，GORM将会只通过非零值字段查询，这意味着如果你的字段值为`0`，`''`，`false`或者其他`零值`时，将不会被用于构建查询条件，例如：

```go
	// SELECT * FROM `users` WHERE `users`.`age` = 18
	db.Where(&User{Name: "", Age: 18}).Find(&users)

	// SELECT * FROM `users` WHERE `age` = 20 AND `name` = '' map来避免
	db.Where(map[string]interface{}{"name": "", "age": 20}).Find(&users)
```

可以使用指针或实现 Scanner/Valuer 接口来避免这个问题.

```go
// 使用指针
type User struct {
  gorm.Model
  Name string
  Age  *int
}

// 使用 Scanner/Valuer
type User struct {
	ID int64
	Name sql.NullString `gorm:"default:'zsss'"` // sql.NullString 实现了Scanner/Valuer接口
	Age  int64
}
	
	var users []User
	db.Debug().Where(&User{Name: sql.NullString{"",true}, Age: 18}).Find(&users)
	fmt.Println(users)
```

**Not 条件**

作用与 Where 类似的情形如下：

```go
    db.Not("name", "zzz").First(&user)
    // SELECT * FROM users WHERE name <> "zzz" LIMIT 1;

    // Not In
    db.Not("name", []string{"zzz", "z1"}).Find(&users)
    // SELECT * FROM users WHERE name NOT IN ("zzz", "z1");

    // Not In slice of primary keys
    db.Not([]int64{1,2,3}).First(&user)
    // SELECT * FROM users WHERE id NOT IN (1,2,3);

    db.Not([]int64{}).First(&user)
    // SELECT * FROM users;

    // Plain SQL
    db.Not("name = ?", "zzz").First(&user)
    // SELECT * FROM users WHERE NOT(name = "zzz");

    // Struct
    db.Not(User{Name: "zzz"}).First(&user)
    // SELECT * FROM users WHERE name <> "zzz";
```

**Or条件**

```go
    db.Where("name = ?", "zzz").Or("name = ?", "z1").Find(&users)
    // SELECT * FROM users WHERE name = 'zzz' OR name = 'z1';

    // Struct
    db.Where("name = 'zzz'").Or(User{Name: "z1"}).Find(&users)
    // SELECT * FROM users WHERE name = 'zzz' OR name = 'z1';

    // Map
    db.Where("name = 'zzz'").Or(map[string]interface{}{"name": "z1"}).Find(&users)
    // SELECT * FROM users WHERE name = 'zzz' OR name = 'z1';
```

**内联条件**

作用与`Where`查询类似，当内联条件与多个[立即执行方法](https://www.liwenzhou.com/posts/Go/gorm_crud/#autoid-1-3-1)一起使用时, 内联条件不会传递给后面的立即执行方法。

```go
    // 根据主键获取记录 (只适用于整形主键)
    db.First(&user, 23) 
	// SELECT * FROM users WHERE id = 23 LIMIT 1;

    // 根据主键获取记录, 如果它是一个非整形主键
    db.First(&user, "id = ?", "string_primary_key")
	// SELECT * FROM users WHERE id = 'string_primary_key' LIMIT 1;

    // Plain SQL
    db.Find(&user, "name = ?", "zzz")
    // SELECT * FROM users WHERE name = "zzz";

    db.Find(&users, "name <> ? AND age > ?", "zzz", 20)
    // SELECT * FROM users WHERE name <> "zzz" AND age > 20;

    // Struct
    db.Find(&users, User{Age: 20})
    // SELECT * FROM users WHERE age = 20;

    // Map
    db.Find(&users, map[string]interface{}{"age": 20})
    // SELECT * FROM users WHERE age = 20;
```

**额外查询选项**

```go
    // 为查询 SQL 添加额外的 SQL 操作
    // 上一个排它锁,也就是说,其他的事务是可以读取的。但是不能写入或者更新。
    db.Set("gorm:query_option", "FOR UPDATE").First(&user, 10)
    // SELECT * FROM users WHERE id = 10 FOR UPDATE;
```

**FirstOrInit**

获取匹配的第一条记录，否则根据给定的条件初始化一个新的对象 (仅支持 struct 和 map 条件)

```go
    // 未找到
    db.FirstOrInit(&user, User{Name: "non_existing"})
    // user -> User{Name: "non_existing"}

    // 找到
    db.Where(User{Name: "zzz"}).FirstOrInit(&user)
    // user -> User{Id: 111, Name: "zzz", Age: 20}

    db.FirstOrInit(&user, map[string]interface{}{"name": "zzz"})
    // user -> User{Id: 111, Name: "zzz", Age: 20}
```

**Attrs**

如果记录未找到，将使用参数初始化 struct.

```go
    // 未找到
    db.Where(User{Name: "non_existing"}).Attrs(User{Age: 20}).FirstOrInit(&user)
    // SELECT * FROM USERS WHERE name = 'non_existing';
    // user -> User{Name: "non_existing", Age: 20}

    db.Where(User{Name: "non_existing"}).Attrs("age", 20).FirstOrInit(&user)
    // SELECT * FROM USERS WHERE name = 'non_existing';
    // user -> User{Name: "non_existing", Age: 20}

    // 找到则不设置
    db.Where(User{Name: "zzz"}).Attrs(User{Age: 30}).FirstOrInit(&user)
    // SELECT * FROM USERS WHERE name = 'zzz';
    // user -> User{Id: 111, Name: "zzz", Age: 20}
```

**Assign**

不管记录是否找到，都将参数赋值给 struct.

```go
    // 未找到
    db.Where(User{Name: "non_existing"}).Assign(User{Age: 20}).FirstOrInit(&user)
    // user -> User{Name: "non_existing", Age: 20}

    // 找到
    db.Where(User{Name: "zzz"}).Assign(User{Age: 30}).FirstOrInit(&user)
    // SELECT * FROM USERS WHERE name = zzz';
    // user -> User{Id: 111, Name: "zzz", Age: 30}
```

**FirstOrCreate**

获取匹配的第一条记录, 否则根据给定的条件创建一个新的记录 (仅支持 struct 和 map 条件)

```go
    // 未找到
    db.FirstOrCreate(&user, User{Name: "non_existing"})
    // INSERT INTO "users" (name) VALUES ("non_existing");
    // user -> User{Id: 112, Name: "non_existing"}

    // 找到
    db.Where(User{Name: "zzz"}).FirstOrCreate(&user)
    // user -> User{Id: 111, Name: "zzz"}
```

**Attrs**

如果记录未找到，将使用参数创建 struct 和记录.

```go
    // 未找到
    db.Where(User{Name: "non_existing"}).Attrs(User{Age: 20}).FirstOrCreate(&user)
    // SELECT * FROM users WHERE name = 'non_existing';
    // INSERT INTO "users" (name, age) VALUES ("non_existing", 20);
    // user -> User{Id: 112, Name: "non_existing", Age: 20}

    // 找到
    db.Where(User{Name: "zzz"}).Attrs(User{Age: 30}).FirstOrCreate(&user)
    // SELECT * FROM users WHERE name = 'zzz';
    // user -> User{Id: 111, Name: "zzz", Age: 20}
```

**Assign**

不管记录是否找到，都将参数赋值给 struct 并保存至数据库.

```go
    // 未找到
    db.Where(User{Name: "non_existing"}).Assign(User{Age: 20}).FirstOrCreate(&user)
    // SELECT * FROM users WHERE name = 'non_existing';
    // INSERT INTO "users" (name, age) VALUES ("non_existing", 20);
    // user -> User{Id: 112, Name: "non_existing", Age: 20}

    // 找到
    db.Where(User{Name: "zzz"}).Assign(User{Age: 30}).FirstOrCreate(&user)
    // SELECT * FROM users WHERE name = 'zzz';
    // UPDATE users SET age=30 WHERE id = 111;
    // user -> User{Id: 111, Name: "zzz", Age: 30}
```

###### **高级查询**

**子查询**

```go
    db.Where("amount > ?", db.Table("orders").Select("AVG(amount)").Where("state = ?", "paid").SubQuery()).Find(&orders)
    // SELECT * FROM "orders"  WHERE "orders"."deleted_at" IS NULL AND (amount > (SELECT AVG(amount) FROM "orders"  WHERE (state = 'paid')));
```

**选择字段**

Select，指定你想从数据库中检索出的字段，默认会选择全部字段。

```go
    // select coalesce(a,b,c);  如果a==null,则选择b；如果b==null,则选择c；如果a!=null,则选择a；如果a b c 都为null ，则返回为null（没意义）。

    db.Select("name, age").Find(&users)
    // SELECT name, age FROM users;

    db.Select([]string{"name", "age"}).Find(&users)
    // SELECT name, age FROM users;

    db.Table("users").Select("COALESCE(age,?)", 42).Rows()
    // SELECT COALESCE(age,'42') FROM users;
```

**排序**

Order，指定从数据库中检索出记录的顺序。设置第二个参数 order 为 `true` ，可以覆盖前面定义的排序条件。

```go
    db.Order("age desc, name").Find(&users)
    // SELECT * FROM users ORDER BY age desc, name;

    // 多字段排序
    db.Order("age desc").Order("name").Find(&users)
    // SELECT * FROM users ORDER BY age desc, name;

    // 覆盖排序
    db.Order("age desc").Find(&users1).Order("age", true).Find(&users2)
    // SELECT * FROM users ORDER BY age desc; (users1)
    // SELECT * FROM users ORDER BY age; (users2)
```

**数量**

Limit，指定从数据库检索出的最大记录数。

```go
    db.Limit(3).Find(&users)
    // SELECT * FROM users LIMIT 3;

    // -1 取消 Limit 条件
    db.Limit(10).Find(&users1).Limit(-1).Find(&users2)
    // SELECT * FROM users LIMIT 10; (users1)
    // SELECT * FROM users; (users2)
```

**偏移**

Offset，指定开始返回记录前要跳过的记录数。

```go
    db.Debug().Limit(2).Offset(3).Find(&users)
    // SELECT * FROM `users` LIMIT 2 OFFSET 3  
    // -1 取消 Offset 条件`
```

**总数**

Count，该 model 能获取的记录总数。

```go
    db.Where("name = ?", "zzz").Or("name = ?", "z1").Find(&users).Count(&count)
    // SELECT * from USERS WHERE name = 'zzz' OR name = 'z1'; (users)
    // SELECT count(*) FROM users WHERE name = 'zzz' OR name = 'z1'; (count)

    db.Model(&User{}).Where("name = ?", "zzz").Count(&count)
    // SELECT count(*) FROM users WHERE name = 'zzz'; (count)

    db.Table("users").Count(&count)
    // SELECT count(*) FROM users;

    db.Table("users").Select("count(distinct(name))").Count(&count)
    // SELECT count( distinct(name) ) FROM users; (count)
```

**注意** `Count` 必须是链式查询的最后一个操作 ，因为它会覆盖前面的 `SELECT`，但如果里面使用了 `count` 时不会覆盖

**Group & Having**

```go
    rows, err := db.Table("orders").Select("date(created_at) as date, sum(amount) as total").Group("date(created_at)").Rows()
    for rows.Next() {
      ...
    }

    // 使用Scan将多条结果扫描进事先准备好的结构体切片中
    type Result struct {
        Date time.Time
        Total int
    }
    var rets []Result
    db.Table("users").Select("date(created_at) as date, sum(age) as total").Group("date(created_at)").Scan(&rets)


    rows, err := db.Table("orders").Select("date(created_at) as date, sum(amount) as total").Group("date(created_at)").Having("sum(amount) > ?", 100).Rows()
    for rows.Next() {
      ...
    }

    type Result struct {
      Date  time.Time
      Total int64
    }
	var results []Result
    db.Table("orders").Select("date(created_at) as date, sum(amount) as total").Group("date(created_at)").Having("sum(amount) > ?", 100).Scan(&results)
```

**连接**

Joins，指定连接条件

```go
    rows, err := db.Table("users").Select("users.name, emails.email").Joins("left join emails on emails.user_id = users.id").Rows()
    for rows.Next() {
      ...
    }

    db.Table("users").Select("users.name, emails.email").Joins("left join emails on emails.user_id = users.id").Scan(&results)
```

**Pluck**

Pluck，查询 model 中的一个列作为切片

```go
    var ages []int64
    db.Find(&users).Pluck("age", &ages)

    var names []string
    db.Model(&User{}).Pluck("name", &names)

    db.Table("deleted_users").Pluck("name", &names)

    // 想查询多个字段？ 这样做：
    db.Select("name, age").Find(&users)
```

**扫描**

Scan，扫描结果至一个 struct.

```go
    type Result struct {
      Name string
      Age  int
    }

    var result Result
    db.Table("users").Select("name, age").Where("name = ?", "Antonio").Scan(&result)

    var results []Result
    db.Table("users").Select("name, age").Where("id > ?", 0).Scan(&results)

    // 原生 SQL
    db.Raw("SELECT name, age FROM users WHERE name = ?", "Antonio").Scan(&result)
```

**链式操作相关**

**链式操作**

Method Chaining，Gorm 实现了链式操作接口，所以你可以把代码写成这样：

```go
    // 创建一个查询
    tx := db.Where("name = ?", "zzz")

    // 添加更多条件
    if someCondition {
      tx = tx.Where("age = ?", 20)
    } else {
      tx = tx.Where("age = ?", 30)
    }
    // 添加更多条件
    if yetAnotherCresultsondition {
      tx = tx.Where("active = ?", 1)
    }
```

在调用立即执行方法前不会生成`Query`语句，借助这个特性你可以创建一个函数来处理一些通用逻辑。

**立即执行方法**

Immediate methods ，立即执行方法是指那些会立即生成`SQL`语句并发送到数据库的方法, 他们一般是`CRUD`方法，比如：

`Create`, `First`, `Find`, `Take`, `Save`, `UpdateXXX`, `Delete`, `Scan`, `Row`, `Rows`…

这有一个基于上面链式方法代码的立即执行方法的例子：

```go
tx.Find(&user)
```

生成的SQL语句如下：

```go
SELECT * FROM users where name = 'zzz' AND age = 30 AND active = 1;
```

**范围**

`Scopes`，Scope是建立在链式操作的基础之上的。

基于它，你可以抽取一些通用逻辑，写出更多可重用的函数库。

```go
func AmountGreaterThan1000(db *gorm.DB) *gorm.DB {
  return db.Where("amount > ?", 1000)
}

func PaidWithCreditCard(db *gorm.DB) *gorm.DB {
  return db.Where("pay_mode_sign = ?", "C")
}

func PaidWithCod(db *gorm.DB) *gorm.DB {
  return db.Where("pay_mode_sign = ?", "C")
}

func OrderStatus(status []string) func (db *gorm.DB) *gorm.DB {
  return func (db *gorm.DB) *gorm.DB {
    return db.Scopes(AmountGreaterThan1000).Where("status IN (?)", status)
  }
}

db.Scopes(AmountGreaterThan1000, PaidWithCreditCard).Find(&orders)
// 查找所有金额大于 1000 的信用卡订单

db.Scopes(AmountGreaterThan1000, PaidWithCod).Find(&orders)
// 查找所有金额大于 1000 的 COD 订单

db.Scopes(AmountGreaterThan1000, OrderStatus([]string{"paid", "shipped"})).Find(&orders)
// 查找所有金额大于 1000 且已付款或者已发货的订单
```

**多个立即执行方法**

Multiple Immediate Methods，在 GORM 中使用多个立即执行方法时，后一个立即执行方法会复用前一个立即执行方法的条件 (**不包括内联条件**) 。

```go
db.Where("name LIKE ?", "z%").Find(&users, "id IN (?)", []int{1, 2, 3}).Count(&count)
```

生成的 Sql

```go
SELECT * FROM users WHERE name LIKE 'z%' AND id IN (1, 2, 3)
SELECT count(*) FROM users WHERE name LIKE 'z%' // 不包括内联条件
```

##### **更新**

**更新所有字段**

`Save()`默认会更新该对象的所有字段，即使没有赋值。

```go
	// 更改 save是一个集create和insert为一体的操作
	var user User
	db.First(&user)
	user.Name = sql.NullString{"a",true}
	db.Debug().Save(&user) // UPDATE `users` SET `name`='a',`age`=18 WHERE `id` = 1
	fmt.Println(user)

	user.ID = 0 // 无id就是插入
	db.Debug().Save(&user) // INSERT INTO `users` (`name`,`age`) VALUES ('a',18)
```

**更新修改字段**

如果你只希望更新指定字段，可以使用`Update`或者`Updates`

```go
	// update更新
	// 更新单个属性，如果它有变化
	// db.First(&user)
	// db.Model(&user).Update("name", "hello")
	// UPDATE `users` SET `name`='hello' WHERE `id` = 1

	// 根据给定的条件更新单个属性
	// db.Model(&user).Where("Age = ?", 18).Update("name", "hello")
	// UPDATE `users` SET `name`='hello' WHERE Age = 18

	// 使用 map 更新多个属性，只会更新其中有变化的属性
	//db.First(&user)
	//db.Model(&user).Updates(map[string]interface{}{"name": "hello", "age": 15})
	// UPDATE `users` SET `age`=15,`name`='hello' WHERE `id` = 1

	// 使用 struct 更新多个属性，只会更新其中有变化且为非零值的字段
	//db.First(&user)
	//db.Model(&user).Updates(User{Name: sql.NullString{"hello",true}, Age: 18})
	// UPDATE `users` SET `name`='hello',`age`=18 WHERE `id` = 1

	db.First(&user)
	db.Model(&user).Updates(User{Name: sql.NullString{"",true}, Age: 0})
	// UPDATE `users` SET `name`='' WHERE `id` = 1
```

**更新选定字段**

如果你想更新或忽略某些字段，你可以使用 `Select`，`Omit`

```go
    // 只更新age字段
	//db.First(&user)
	//db.Model(&user).Select("name").Updates(map[string]interface{}{"name": "hello", "age": 18})
	// UPDATE `users` SET `name`='hello' WHERE `id` = 1

	// 除了name字段以外其余map字段都更新
	db.First(&user)
	db.Model(&user).Omit("name").Updates(map[string]interface{}{"name": "hello", "age": 18})
	// UPDATE `users` SET `age`=18 WHERE `id` = 1
```

**无Hooks更新**

上面的更新操作会自动运行 model 的 `BeforeUpdate`, `AfterUpdate` 方法，更新 `UpdatedAt` 时间戳, 在更新时保存其 `Associations`, 如果你不想调用这些方法，你可以使用 `UpdateColumn`， `UpdateColumns`

```go
    // 更新单个属性，类似于 `Update`
    db.First(&user)
    db.Model(&user).UpdateColumn("name", "hello")
    // UPDATE users SET name='hello' WHERE id = 1;

    // 更新多个属性，类似于 `Updates`
    db.First(&user)
    db.Model(&user).UpdateColumns(User{Name: "hello", Age: 18})
    // UPDATE users SET name='hello', age=18 WHERE id = 1;
```

**批量更新**

批量更新时`Hooks（钩子函数）`不会运行。

```go
    db.Table("users").Where("id IN (?)", []int{10, 11}).Updates(map[string]interface{}{"name": "hello", "age": 18})
    // UPDATE users SET name='hello', age=18 WHERE id IN (10, 11);

    // 使用 struct 更新时，只会更新非零值字段，若想更新所有字段，请使用map[string]interface{}
    db.First(&user)
    db.Model(User{}).Updates(User{Name: "hello", Age: 18})
    // UPDATE users SET name='hello', age=18 WHERE id = 1;

    // 使用 `RowsAffected` 获取更新记录总数
    a := db.Model(User{}).Updates(User{Name:sql.NullString{"hello",true}, Age: 18}).RowsAffected
```

**使用SQL表达式更新**

先查询表中的第一条数据保存至user变量。

```go
    var user User
    db.First(&user)
    db.Model(&user).Update("age", gorm.Expr("age * ? + ?", 2, 100))
    // UPDATE `users` SET `age` = age * 2 + 100  WHERE `users`.`id` = 1;

    db.Model(&user).Updates(map[string]interface{}{"age": gorm.Expr("age * ? + ?", 2, 100)})
    // UPDATE "users" SET "age" = age * '2' + '100' WHERE `users`.`id` = 1;

    db.Model(&user).UpdateColumn("age", gorm.Expr("age - ?", 1))
    // UPDATE "users" SET "age" = age - 1 WHERE "id" = '1';

    db.Model(&user).Where("age > 10").UpdateColumn("age", gorm.Expr("age - ?", 1))
    // UPDATE "users" SET "age" = age - 1 WHERE "id" = '1' AND age > 10;
```

**修改Hooks中的值**

如果你想修改 `BeforeUpdate`, `BeforeSave` 等 Hooks 中更新的值，你可以使用 `scope.SetColumn`, 例如：

```go
func (user *User) BeforeSave(scope *gorm.Scope) (err error) {
  // 存储前加密
  if pw, err := bcrypt.GenerateFromPassword(user.Password, 0); err == nil {
    scope.SetColumn("EncryptedPassword", pw)
  }
}
```

##### **删除**

**删除记录**

删除记录时，请确保主键字段有值，GORM 会通过主键去删除记录，如果主键为空，GORM 会删除该 model 的所有记录。

```go
    // 删除
    var user User
    user.ID = 1
    db.Debug().Delete(&user) 
    // DELETE FROM `users`  WHERE `users`.`id` = 1  
```

**批量删除**

删除全部匹配的记录

```go
    db.Where("name LIKE ?", "%z%").Delete(User{})
    // DELETE from `users` where name LIKE "%z%";

    db.Delete(User{}, "name LIKE ?", "%z%")
    // DELETE from `users` where name LIKE "%z%";
```

**软删除**

如果一个 model 有 `DeletedAt` 字段，他将自动获得软删除的功能！ 当调用 `Delete` 方法时， 记录不会真正的从数据库中被删除， 只会将`DeletedAt` 字段的值会被设置为当前时间

```go
    db.First(&user)
	db.Delete(&user)
    // UPDATE users SET deleted_at="2022-02-29 10:23" WHERE id = 1;	

    // 批量删除
    db.Where("age = ?", 20).Delete(&User{})
    // UPDATE users SET deleted_at="2022-02-29 10:23" WHERE age = 20;

    // 查询记录时会忽略被软删除的记录
    db.Where("age = 20").Find(&user)
    // SELECT * FROM users WHERE age = 20 AND deleted_at IS NULL;

    // Unscoped 方法可以查询出被软删除的记录
    db.Unscoped().Where("age = 20").Find(&users)
    // SELECT * FROM users WHERE age = 20;
```

**物理删除**

```go
    // Unscoped 方法可以物理删除记录
	db.First(&user)
    db.Unscoped().Delete(&users)
    // DELETE FROM users WHERE id=1;
```

##### Belongs To

```go
package main

import (
	"fmt"
	"gorm.io/driver/mysql"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"
	"log"
	"os"
	"time"
)

// 一个用户属于一个company，所以用户只当company
// `User` 属于 `Company`，`CompanyID` 是外键
type NUser struct {
	gorm.Model
	Name      string
	CompanyID int // 数据库中存储的字段
	Company   Company
}

type Company struct {
	ID   int
	Name string
}


func main() {
	dsn := "root:zxy19981013@(127.0.0.1:3306)/fwbzs?charset=utf8mb4&parseTime=True&loc=Local"

	// 设置全局的logger 会在我们执行每个sql语句的时候打印sql
	newLogger := logger.New(
		log.New(os.Stdout, "\r\n", log.LstdFlags), // io.write
		logger.Config{
			SlowThreshold: time.Second, // 慢sql阈值
			LogLevel:      logger.Info, // sql 输出 level
			Colorful:      true,        // 使用彩色打印
		})

	// 打开数据库
	db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{
		Logger: newLogger,
	})
	if err != nil {
		panic(err)
	}

	// 定义一个表结构 自动迁移 将结构体和数据表同步 自动创建n_users companies表，并设置外键
	db.AutoMigrate(&NUser{}) // 此处有sql语句
	// CREATE TABLE `companies` (`id` bigint AUTO_INCREMENT,`name` longtext,PRIMARY KEY (`id`))
	// CREATE TABLE `n_users` (`id` bigint unsigned AUTO_INCREMENT,`created_at` datetime(3) NULL,`updated_at` datetime(3) NULL,`deleted_at` datetime(3) NULL,`name` longtext,`company_id` bigint,PRIMARY KEY (`id`),INDEX idx_n_users_deleted_at (`deleted_at`),CONSTRAINT `fk_n_users_company` FOREIGN KEY (`company_id`) REFERENCES `companies`(`id`))

	// 关联保存 并增加外键数据
	db.Create(&NUser{
		Name: "ZZZZ",
		Company: Company{
			Name: "GS",
		},
	})
	// INSERT INTO `companies` (`name`) VALUES ('GS') ON DUPLICATE KEY UPDATE `id`=`id`
	// INSERT INTO `n_users` (`created_at`,`updated_at`,`deleted_at`,`name`,`company_id`) VALUES ('2022-02-17 09:46:46.667','2022-02-17 09:46:46.667',NULL,'ZZZZ',1)

	// 关联保存 不增加外键数据
	db.Create(&NUser{
		Name: "Z1ZZZ",
		Company: Company{
			ID: 1,
		},
	})
	// INSERT INTO `companies` (`name`,`id`) VALUES ('',1) ON DUPLICATE KEY UPDATE `id`=`id`
	// INSERT INTO `n_users` (`created_at`,`updated_at`,`deleted_at`,`name`,`company_id`) VALUES ('2022-02-17 09:49:25.793','2022-02-17 09:49:25.793',NULL,'Z1ZZZ',1)

	var user NUser
	//db.Preload("Company").First(&user)
	//// SELECT * FROM `companies` WHERE `companies`.`id` = 1
	//// SELECT * FROM `n_users` WHERE `n_users`.`deleted_at` IS NULL ORDER BY `n_users`.`id` LIMIT 1
	//fmt.Println(user.Name,user.Company.Name) // ZZZZ GS

	db.Joins("Company").First(&user)
	// SELECT `n_users`.`id`,`n_users`.`created_at`,`n_users`.`updated_at`,`n_users`.`deleted_at`,`n_users`.`name`,`n_users`.`company_id`,`Company`.`id` AS `Company__id`,`Company`.`name` AS `Company__name` FROM `n_users` LEFT JOIN `companies` `Company` ON `n_users`.`company_id` = `Company`.`id` WHERE `n_users`.`deleted_at` IS NULL ORDER BY `n_users`.`id` LIMIT 1
	fmt.Println(user.Name,user.Company.Name) // ZZZZ GS
}
```

##### **HasMany**

```go
package main

import (
	"fmt"
	"gorm.io/driver/mysql"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"
	"log"
	"os"
	"time"
)

// user有多张card
type ZUser struct {
	gorm.Model
	CreditCards []CreditCard `gorm:"foreignKey:UserId;"`
}
// card属于某一个人
type CreditCard struct {
	gorm.Model
	Number string
	UserId uint
	// 在大型系统中外键约束对系统性能影响较大，但是外键约束的好处就是可以保证数据的一致性，即使在业务层面考虑的不严谨
	// user ZUser
}


func main() {
	dsn := "root:zxy19981013@(127.0.0.1:3306)/fwbzs?charset=utf8mb4&parseTime=True&loc=Local"

	// 设置全局的logger 会在我们执行每个sql语句的时候打印sql
	newLogger := logger.New(
		log.New(os.Stdout, "\r\n", log.LstdFlags), // io.write
		logger.Config{
			SlowThreshold: time.Second, // 慢sql阈值
			LogLevel:      logger.Info, // sql 输出 level
			Colorful:      true,        // 使用彩色打印
		})

	// 打开数据库
	db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{
		Logger: newLogger,
	})
	if err != nil {
		panic(err)
	}

	//// 定义一个表结构 自动迁移 将结构体和数据表同步 自动创建n_users companies表，并设置外键
	//db.AutoMigrate(&CreditCard{}) // 此处有sql语句
	//// CREATE TABLE `credit_cards` (`id` bigint unsigned AUTO_INCREMENT,`created_at` datetime(3) NULL,`updated_at` datetime(3) NULL,`deleted_at` datetime(3) NULL,`number` longtext,`user_id` bigint unsigned,PRIMARY KEY (`id`),INDEX idx_credit_cards_deleted_at (`deleted_at`))
	//db.AutoMigrate(&ZUser{}) // 此处有sql语句
	//// CREATE TABLE `z_users` (`id` bigint unsigned AUTO_INCREMENT,`created_at` datetime(3) NULL,`updated_at` datetime(3) NULL,`deleted_at` datetime(3) NULL,PRIMARY KEY (`id`),INDEX idx_z_users_deleted_at (`deleted_at`))
	//
	//
	//// 关联保存 并增加外键数据
	//user := ZUser{}
	//db.Create(&user)
	//// INSERT INTO `z_users` (`created_at`,`updated_at`,`deleted_at`) VALUES ('2022-02-17 12:23:08.218','2022-02-17 12:23:08.218',NULL)
	//
	//db.Create(&CreditCard{
	//	Number: "12",
	//	UserId: user.ID,
	//})
	//// INSERT INTO `credit_cards` (`created_at`,`updated_at`,`deleted_at`,`number`,`user_id`) VALUES ('2022-02-17 12:23:08.231','2022-02-17 12:23:08.231',NULL,'12',1)
	//db.Create(&CreditCard{
	//	Number: "34",
	//	UserId: user.ID,
	//})
	//// INSERT INTO `credit_cards` (`created_at`,`updated_at`,`deleted_at`,`number`,`user_id`) VALUES ('2022-02-17 12:23:08.239','2022-02-17 12:23:08.239',NULL,'34',1)


	var users ZUser
	db.Preload("CreditCards").First(&users)
	// SELECT * FROM `credit_cards` WHERE `credit_cards`.`user_id` = 1 AND `credit_cards`.`deleted_at` IS NULL
	// SELECT * FROM `z_users` WHERE `z_users`.`deleted_at` IS NULL ORDER BY `z_users`.`id` LIMIT 1
	for _,card := range users.CreditCards{
		fmt.Println(card.Number)
	}
}
```

##### **ManyToMany**

```go
package main

import (
	"fmt"
	"gorm.io/driver/mysql"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"
	"log"
	"os"
	"time"
)

// user会多种语言
type SUser struct {
	gorm.Model
	Languages []Language `gorm:"many2many:user_languages;"`
}
// language可以多个人
type Language struct {
	gorm.Model
	Name string
}


func main() {
	dsn := "root:zxy19981013@(127.0.0.1:3306)/fwbzs?charset=utf8mb4&parseTime=True&loc=Local"

	// 设置全局的logger 会在我们执行每个sql语句的时候打印sql
	newLogger := logger.New(
		log.New(os.Stdout, "\r\n", log.LstdFlags), // io.write
		logger.Config{
			SlowThreshold: time.Second, // 慢sql阈值
			LogLevel:      logger.Info, // sql 输出 level
			Colorful:      true,        // 使用彩色打印
		})

	// 打开数据库
	db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{
		Logger: newLogger,
	})
	if err != nil {
		panic(err)
	}


	//db.AutoMigrate(&SUser{}) // 此处有sql语句
	//// CREATE TABLE `s_users` (`id` bigint unsigned AUTO_INCREMENT,`created_at` datetime(3) NULL,`updated_at` datetime(3) NULL,`deleted_at` datetime(3) NULL,PRIMARY KEY (`id`),INDEX idx_s_users_deleted_at (`deleted_at`))
	//// CREATE TABLE `languages` (`id` bigint unsigned AUTO_INCREMENT,`created_at` datetime(3) NULL,`updated_at` datetime(3) NULL,`deleted_at` datetime(3) NULL,`name` longtext,PRIMARY KEY (`id`),INDEX idx_languages_deleted_at (`deleted_at`))
	//// CREATE TABLE `user_languages` (`s_user_id` bigint unsigned,`language_id` bigint unsigned,PRIMARY KEY (`s_user_id`,`language_id`),CONSTRAINT `fk_user_languages_s_user` FOREIGN KEY (`s_user_id`) REFERENCES `s_users`(`id`),CONSTRAINT `fk_user_languages_language` FOREIGN KEY (`language_id`) REFERENCES `languages`(`id`))
	//
	//
	//// 关联保存 并增加外键数据
	//languages := []Language{}
	//languages = append(languages,Language{Name: "go"})
	//languages = append(languages,Language{Name: "py"})
	//user := SUser{
	//	Languages: languages,
	//}
	//db.Create(&user)
	//// INSERT INTO `languages` (`created_at`,`updated_at`,`deleted_at`,`name`) VALUES ('2022-02-17 12:40:47.365','2022-02-17 12:40:47.365',NULL,'go'),('2022-02-17 12:40:47.365','2022-02-17 12:40:47.365',NULL,'py') ON DUPLICATE KEY UPDATE `id`=`id`
	//// INSERT INTO `user_languages` (`s_user_id`,`language_id`) VALUES (1,1),(1,2) ON DUPLICATE KEY UPDATE `s_user_id`=`s_user_id`
	//// INSERT INTO `s_users` (`created_at`,`updated_at`,`deleted_at`) VALUES ('2022-02-17 12:40:47.362','2022-02-17 12:40:47.362',NULL)


	var users SUser
	db.Preload("Languages").First(&users)
	// SELECT * FROM `s_users` WHERE `s_users`.`deleted_at` IS NULL ORDER BY `s_users`.`id` LIMIT 1
	// SELECT * FROM `user_languages` WHERE `user_languages`.`s_user_id` = 1
	// SELECT * FROM `languages` WHERE `languages`.`id` IN (1,2) AND `languages`.`deleted_at` IS NULL
	for _,l := range users.Languages{
		fmt.Println(l.Name)
	}


	// 若是已经有一个用户，根据此用户查language
	var userss SUser
	db.First(&userss)
	// SELECT * FROM `s_users` WHERE `s_users`.`deleted_at` IS NULL ORDER BY `s_users`.`id` LIMIT 1
	var languages []Language
	_ = db.Model(&userss).Association("Languages").Find(&languages)
	// SELECT `languages`.`id`,`languages`.`created_at`,`languages`.`updated_at`,`languages`.`deleted_at`,`languages`.`name` FROM `languages` JOIN `user_languages` ON `user_languages`.`language_id` = `languages`.`id` AND `user_languages`.`s_user_id` = 1 WHERE `languages`.`deleted_at` IS NULL
	for _,language := range  languages{
		fmt.Println(language.Name)
	}
}
```