**传统分层**

**MVC**

![1638441025006](F:\markdown笔记\Go高级工程师实战\image\1638441025006.png)

当前后端分离成为主流共识，View不用了

![1638441069690](F:\markdown笔记\Go高级工程师实战\image\1638441069690.png)

后端业务逻辑越来越复杂，拆成单独的 logic (dao data access object)

![1638441149137](F:\markdown笔记\Go高级工程师实战\image\1638441149137.png)

业务代码越来越多了，看不懂怎么办 

> **贫⾎模式** 
>
> 业务逻辑都在 logic 层内 ，Struct、Class 上没有任何逻辑，或只有少量逻辑 ，作为不同层间通信使用。
>
> ![1638442734688](F:\markdown笔记\Go高级工程师实战\image\1638442734688.png)
>
> **充⾎模式** 
>
> 要让 domain object 即 entity 有更多逻辑，通过聚合来组合 entity 的逻辑，主流程根据不同的⽤例选择执⾏不同的对象函数，⽽不是⽤数据建模，将所有处理集中在同⼀个函数⾥
>
> ![1638441589492](F:\markdown笔记\Go高级工程师实战\image\1638441589492.png)

**面向对象的五个原则 SOLID**

> **单一职责原则（SRP）**
>
> 不要存在多于一个导致类变更的原因，即一个类只负责一项职责
>
> **开放封闭原则（OCP）**
>
> 一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展
>
> **里氏替换原则（LSP）**
>
> 所有引用父类的地方必须能透明的使用其子类的对象(即传User对象不报错的情况下 传VIPUser对象也不能报错)
>
> **接口隔离原则（ISP）**
>
> 使用多个专门的接口，而不使用单一的总接口，高层不应该依赖那些他不需要的接口。用多继承实现多个接口
>
> **依赖倒置原则（DIP）**
>
> 高层模块不应该依赖低层模块，二者都应该依赖其抽象(接口)；抽象不应该依赖细节，细节应该依赖抽象；要针对接口编程，而不是针对实现编程

通过 DIP，我们可以做到依赖⽅向与程序控制⽅向相反

![1638442752856](F:\markdown笔记\Go高级工程师实战\image\1638442752856.png)

**整洁架构style**

![1638442777401](F:\markdown笔记\Go高级工程师实战\image\1638442777401.png)

> • **不与框架绑定**：业务不应该与某个 web 框架绑定，应该做到想换就换。 
>
> (业务代码⼊⼝不应与任何协议绑定，框架代码(如 gin.Context)不要⼊侵到业务层)
>
> • **可测试**：业务逻辑应该在没有 UI、database 环境、web server 等所有外部环境的前提下做到可测试。 
>
> • **不与 UI 绑定**：不与具体的 UI 库绑定，项⽬应该做到随意切换外部 UI，⽐如可以将 web UI 替换为 console UI，同时⽆需业务逻辑做修改。 
>
> (我们做的基本上都是前后分离的系统，不太容易与 UI 发⽣绑定)
>
> • **不与数据库绑定**：可以把 Oracle 换成 SQL Server，也可以换成Mongo，换成 BigTable，换成 CouchDB。业务不依赖具体存储⽅式。 
>
> (需要借助 DDD 中的 Repo 设计⽅式，使用接口)
>
> • **不依赖任何外部代理**：你的业务应该对外部环境⼀⽆所知。
>
> (没有外部 agent 也能启动，做到⽐较难。⽐如你是不是经常会碰到： 
>
> • 没有配置下发的 agent 的环节，本系统跑不起来。 
>
> • 没有 service mesh 模块，本系统跑不起来。 
>
> • 没有 metrics 采集模块，本系统跑不起来)

**DDDstyle**

六边形架构，也被称为端⼝与适配器架构，业务逻辑在中心，所有外部类型都有适配器与之对应，外部通过 API 与内部交互 Ports = interface  Adapters = instances

![1638443770544](F:\markdown笔记\Go高级工程师实战\image\1638443770544.png)

> **名词** 数据
>
> **Value Object**  Value Type 是不可变(immutable)，可⽐较(comparable)的值，例如： 数字 字符串 结构体
>
> **Entity** Entity 的关键是其有 ID 作为唯⼀标识，Value type 则没有 ID ，有 ID 意味着 entity 是可变(mutable)的，会随着时间更新
>
> **Aggregate** Aggregate 和 entity 设计上类似，也有 ID，也是可变(mutable)的。聚合可以⽤ entity + value object 构成，每⼀个聚合对应⼀个 Repo interface 存储接口。聚合需要对聚合内的数据⼀致性负责，可以认为聚合是数据⼀致性的边界。聚合之外的⼀致性采⽤最终⼀致性保证。⼀个聚合可以只有⼀个 entity，也可以有多个 entity 和 value object
>
> **Aggregate Root** 聚合根也是聚合，与普通聚合唯⼀差别：聚合根对外暴露，要关联某个领域内的对象，⼀定是通过聚合根的 id 来进⾏关联的。在聚合内的⼀些 entity ⼀般不对外暴露，但随着时间的推移也可能变成聚合根。
>
> **Repository**  业务代码不会和任意数据库实现绑定

![1638444804573](F:\markdown笔记\Go高级工程师实战\image\1638444804573.png)

![1638444855780](F:\markdown笔记\Go高级工程师实战\image\1638444855780.png)

**插件化架构**

![1638445054160](F:\markdown笔记\Go高级工程师实战\image\1638445054160.png)

**其它知识**

main 模块是上帝模块，需要负责初始化所有内部类，如果初始化关系很复杂： 

![1638445122190](F:\markdown笔记\Go高级工程师实战\image\1638445122190.png)

我们可以使⽤ wire 来简化程序的初始化过程