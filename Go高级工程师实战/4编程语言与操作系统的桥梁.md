**操作系统**

操作系统是资源的管理器，其管理的资源均进⾏了抽象
磁盘抽象：⽂件夹
内存抽象：虚拟内存
CPU 抽象：时间⽚

**分级保护域-protection ring**

CPU 为操作系统提供了特殊的安全⽀持，操作系统内核运⾏在特殊模式下，即图中的  ring-0。应⽤运⾏在 ring-3，权限被严格限制，用户不能切换到ring0，只能通过系统调用

![1636964265274](F:\markdown笔记\Go高级工程师实战\image\1636964265274.png)

Intel 64 有四个特权级别，不过实际上只⽤到了其中的两个：ring-0 和 ring-3
ring-1，ring-2本来计划是为驱动程序和 OS 服务⽤，不过流⾏的 OS 们都没有接受这个⽅案。

**系统调⽤**

系统调⽤是操作系统内核为应⽤提供的 API，是内核为应⽤提供的服务，操作系统为上层的应⽤程序提供了⼀个“标准库”，对于应⽤来说，系统调⽤可以实现超出⾃⼰能⼒以外的事情。

go语言函数调用规约中参数未使用寄存器，而是直接放入栈中传参

寄存器：CPU 内部的特殊存储单元

系统调⽤有⾃⼰的⼀套调⽤规约，需要使⽤寄存器，和C语⾔的调⽤规约相似，系统调用参数不可能超过六个，超过六个的部分放到栈上

**SYSCALL 之后发⽣了什么**

![1636964627875](F:\markdown笔记\Go高级工程师实战\image\1636964627875.png)

**常⻅系统调⽤**

![1636964880421](F:\markdown笔记\Go高级工程师实战\image\1636964880421.png)

**观察系统调⽤**

strace

```cmd
strace -c ./x // 查看Go语⾔的程序⽣命周期内的系统调⽤统计 
```

strace 的实现依赖了 ptrace 这个 syscall，调试器(如 delve)也是⼤量使⽤了 ptrace

**Go 语⾔中的系统调⽤**

阻塞和⾮阻塞的系统调⽤

![1636965197885](F:\markdown笔记\Go高级工程师实战\image\1636965197885.png)

为啥还要有个 6 后缀？6 其实说的是 6 个参数。很多系统接⼝也有类似的命名法，如 wait4，accept4

阻塞的系统调⽤需要修改 P 的状态：running -> syscall。这样在 sysmon 中才能发现这个 P 已经在 syscall 状态阻塞了，将G和M解绑定

![1636965422167](F:\markdown笔记\Go高级工程师实战\image\1636965422167.png)

> entrysyscal : 将g.status的状态从running 到 syscall，保存g的现场，准备参数，卡住在SYSCALL，程序的sysmon的循环检查会检查卡住的时间，太长了就会用retake逻辑将P和M剥离，P可以执行别的任务。时间短就不会剥离。
>
> exitsyscall : 将g.status的状态恢复到running，判断M有无P，没有的话将M放入全局队列。





