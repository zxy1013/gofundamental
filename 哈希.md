**哈希**

**1. 常见的数据结构操作性能：**

数据结构						查找						插入						删除

数组 						    O(N)						O(1)						O(N)

有序数组					  O(logN)			   	 O(N)					   O(N)

链表						      O(N)					 	O(1)						O(N) 

有序链表					  O(N)					 	O(N)						O(N)

二叉树(一般情况)        O(logN)					O(logN)					O(logN)

二叉树(最坏情况)		O(N)							O(N)					O(N)

平衡树						  O(logN)					O(logN)					O(logN)

哈希表						  O(1)							O(1)						O(1)

栈          						O(N)

哈希查找可以在外存中查找，可以用哈希表映射到文件，分级查找。最坏情况是所有记录的散列值都冲突，这样就退化为线性查找，时间复杂度为O(N)

**2. STL里常用的几种容器及特点**

**list**：底层是双向链表，在当前结点前后插入新元素的效率为O(1)，当然如果需要有序插入的话，还是会退化为O(n)，因为需要遍历比较元素值 

**vector**：底层是动态数组，把数组的常用操作封装起来，方便使用，插入性能为O(n)，尾插为O(1)，需要注意的是，数组的空间是有限的，空间用尽时会进行扩容，因此平均下来性能比list要差一点点； 

**deque**：双端队列，主要是和 vector 相比较，从头部插入的性能优于 vector，同样也有扩容机制，头尾平均插入效率O(1)； 

**set**：底层是红黑树，要求存储的数据是可以比较的，存储元素不能重复，插入性能是log(n)，树的平衡调整规则会有一定的开销； 

**map**：底层是红黑树，存储的数据类型是 pair（键值对），和 set 相比，map 对存储的值要求没那么高，而把要求转移到键上（键不能重复），插入效率log(n)； 

**pair**：通常是 map 的存储数据类型，只能存储两个值。pair，为map而生

**priority_queue**：底层是个堆结构（大小顶堆），时刻保证队首元素是当前的极值，因此可以拿来排序，插入性能也是log(n)； 

**3. 产生哈希冲突的影响因素**

装填因子 = 数据总数 / 哈希表长，反应的是空间利用率、哈希函数、处理冲突的方法

哈希函数进行模除取余时，最好取**素数**进行模除。 

哈希查找中k个关键字具有同一哈希值，若用线性探测法将这k个关键字对应的记录存入哈希表中，至少要进行 **k(k+1)/2** 次探测。

图的拓扑排序、深度优先、关键路径算法用**栈**辅助  

树的层次遍历、图的广度优先遍历用**队列**辅助

用哈希方法处理碰撞时可能出现堆积（聚集）现象，会受堆积现象直接影响的是平均查找长度，平均查找长度之所以受影响是因为，如果堆积比较严重，每次查找都需要进行多次的比较才能找到所需要的值。为了保证哈希在 key/value 查找模式中的优势，一般，其存储效率不会超过50%。 

**4.哈希函数的构造方法**：

散列函数有共同的性质，则函数值应当以同等概率取其值域的每一个值。 

1.直接定址法：H(key) = a*key + b 

2.除留余数法：H(key) = key % p(p为不大于散列表表长，但最接近或等于表长的质数p) 

3.数字分析法：选取r进制数数码分布较为均匀的若干位作为散列地址 

4.平方取中法：取关键字的平方值的中间几位作为散列地址 

5.折叠法：将关键字分割成位数相同的几部分，然后取这几部份的叠加和作为散列地址 

6.单旋转法：将最后一位数，旋转放置到第一位 

7.随机数法:选择一个随机函数，取关键字的随机函数值为它的散列地址

8.相乘取整法:首先用关键字key乘上某个常数A(0<A<1)，并抽取出key.A的小数部分；然后用m乘以该小数后取整

**散列技术中的冲突是指不同键值的元素对应于相同的存储地址，如果两个关键字的值不等但哈希函数值相等，则称这两个关键字为同义词。**

**5.处理冲突的方法**：

1.开放定址法(闭哈希表) 

​    Hi = (H(key)+di) % m (m表示散列表表长，di为增量序列)

​    1）线性探测法  di = 1 2 3 4 ...

​    2）平方探测法  di = 1^2 -1^2 2^2 -2^2 ...

​    3）伪随机数法  di = 伪随机数序列

2.再散列法

​    Hi = RHi(key) ,i=1 2 3 ... RHi是不同的散列函数

3.拉链法(开哈希表) 

​    把所有的同义词存储在一个线性链表中，线性链表由其散列地址唯一标识。拉链法适用于经常进行插入和删除的情况

4.建立公共溢出区

**6.与开放定址法相比，拉链法有如下几个优点：** 

(1)拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短； 

(2)由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况； 

(3)开放定址法为减少冲突，要求装填因子α较小，故当结点规模较大时会浪费很多空间。而拉链法中可取α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间； 

(4)在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。而对开放地址法构造的散列表，删除结点不能简单地将被删结点的空间置为空，否则将截断在它之后填人散列表的同义词结点的查找路径。这是因为各种开放地址法中，空地址单元(即开放地址)都是查找失败的条件。因此在用开放地址法处理冲突的散列表上执行删除操作，只能在被删结点上做删除标记，而不能真正删除结点。 

**Hash_Map**操作能根据散列值直接定位数据的存储地址，设计良好的hash表能在常数级时间下找到需要的数据，但是更适合于内存中的查找。

**B+树**是一种树状的数据结构，适合做索引，对磁盘数据来说，索引查找是比较高效

**STL_Map**的内部实现是一颗红黑树，但是只是一颗在内存中建立的二叉树，不能用于磁盘操作，而其内存查找性能也比不上Hash查找。因此对于内存中数据，查找性能较好的数据结构是Hash_Map，对于磁盘中数据，查找性能较好的数据结构是B+Tree。 

runtime会把weak对象存放到hash表中，对象的内存地址作为键，当该对象的引用计数为0的时候就会被回收。  

**稀疏矩阵压缩的存储方法是：三元组和十字链表**

三元组表示稀疏矩阵可大大节省空间，但是当涉及到矩阵运算时，要大量移动元素。 将非零元素所在的行、列以及它的值构成一个三元组（i j v）  

十字链表表示法可以避免大量移动元素。 节点结构如下： row col value down指向同列下一个节点 right指向同行下一个节点 

**基于哈希的索引和基于树的索引**

 1、hash索引仅满足“=”、“IN”和“<=>”查询，不能使用范围查询

因为hash索引比较的是经常hash运算之后的hash值，因此只能进行等值的过滤，不能基于范围的查找，因为经过hash算法处理后的hash值的大小关系，并不能保证与处理前的hash大小关系对应。'a' <=> NULL得0，NULL<=> NULL得1。'a' = NULL得NULL，NULL= NULL得NULL。  

2、hash索引无法被用来进行数据的排序操作

由于hash索引中存放的都是经过hash计算之后的值，而hash值的大小关系不一定与hash计算之前的值一样，所以数据库无法利用hash索引中的值进行排序操作。

3、对于组合索引，Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash 值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用。

4、Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。

对于选择性比较低的索引键，如果创建 Hash 索引，那么将会存在大量记录指针信息存于同一个 Hash 值相关联。这样要定位某一条记录时就会非常麻烦，会浪费多次表数据的访问，而造成整体性能低下。 