一座大楼有 n+1 层，地面算作第0层，最高的一层为第 n 层。已知棋子从第0层掉落肯定不会摔碎，从第 i 层掉落可能会摔碎，也可能不会摔碎。 

给定整数 n 作为楼层数，再给定整数 k 作为棋子数，返回如果想找到棋子不会摔碎的最高层数，即使在最差的情况下扔的最小次数。一次只能扔一个棋子。 

```python
class Solution:
    def solve(self , n1 , k1 ):
        # P(N,K)的返回值是N层楼时有K个棋子在最差的情况下扔的最少次数
        # P(0,K) = 0;P(N,1) = N;
        """   N > 0且K > 1, 我们需考虑第1个棋子是从哪层开始扔的。如果第1个棋子从第i层开始扔，那么有以下两种情况:
              (1)碎了。没必要尝试第i层以上的楼层了，接下来的问题就变成了剩下i-1层楼和K-1个棋子，所以总步数为 1+P(i-1, K-1);
              (2)没碎。那么可以知道没必要尝试第i层及其以下的楼层了，接下来的问题就变成了还剩下N-i层和K个棋子，所以总步数为 1+P(N-i, K).
              根据题意应该选取(1)和(2)中较差的那种情况，那么步数最少的情况为， P(N, K) = min{ max{P(i-1, K-1), P(N-i, K)}(1<=i<=N) } + 1。"""
        if n1 <= 1 or k1 == 1:
            return n1
        dp = [[0]*(k1+1) for i in range(n1+1)]
        # P(N,1) = N;
        for i in range(n1+1):
            dp[i][1] = i
        # P(0,K) = 0
        for j in range(k1+1):
            dp[0][j] = 0
        for i in range(1,n1+1):
            for j in range(2,k1+1):
                # 设置初始最大值
                mini = n1 + 2
                for k in range(1,i+1):
                    # 碎了 没碎
                    mini = min(mini, max(dp[k-1][j-1],dp[i-k][j]))
                # 最少次数+1
                dp[i][j] = mini + 1
        return dp[-1][-1]
```

以上解决问题是N层楼有K个棋子最少扔多少次。现在反过来看K个棋子如果可以扔M次，最多可以解决多少楼层这个问题。 `map[i][j]`的意义为i个棋子扔j次最多搞定的楼层数。 

![1640829150(1)](F:\markdown笔记\刷题\动态规划\1640829150(1).jpg)

> 若第1个棋子扔在a层楼是最优的。
>
>   \1. 如果第1个棋子已碎，那么就向下，看i-1个棋子扔j-1次最多搞定多少层楼；
>   \2. 如果第1个棋子没碎，那么就向上，看i个棋子扔j-1次最多搞定多少层楼；
>   \3. a层楼本身也是被搞定的1层；
> 1、2、3的总楼数就是i个棋子扔j次最多搞定的楼数。 

所以转移方程为`dp[i][j] = dp[i-1][j],dp[i][j-1] + 1`

例如，想求5个棋子搞定200层楼最少扔多少次的问题，注意到第5行第8列对应的值为218，是第5行的所有值中第一次超过200的值，则可以知道5个棋子搞定200层楼最少扔8次。同时在map表中其实9列10列的值也完全可以不需要计算，因为算到第8列就已经搞定，那么时间复杂度得到进一步的优化。另外还有一个特别重要的优化，我们知道N层楼用二分的方式扔logN+1次就直接可以确定哪层楼会碎的最低层楼，所以当棋子数大于logN+1时，我们就可以返回logN+1。

```python
package main
import "math"

func solve( n int ,  k int ) int {
    if n <= 1 || k == 1{
        return n
    }
    best := int(math.Log2(float64(n))) + 1 // 棋子数足够则返回最小次数
    if k >= best{
        return best
    }
    // dp[i] 用来表示扔time次，扔1-k个棋子解决的最大层数
    dp := make([]int,k+1)
    // 初始表示 扔1次，扔一个棋子解决的最大层数
    dp[1] = 1
    // 次数累加
    for time := 2;;time++{
        // 棋子个数，从后往前，因为每个计算都需要用到上一轮的前一个的值，我们只用了一个dp存储，所以从前往后计算会改变其值
        for count := k;count >= 1; count--{
            // map[i][j] == map[i-1][j] + map[i-1][j-1] + 1
            dp[count] = dp[count-1] + dp[count] + 1
            if dp[count] >= n{
                return time
            }
        }
    }
}
```

